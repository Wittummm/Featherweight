#version 460 core
// Generated by glsl-transformer
bool iris_discardFragment(vec4 color) {
	return false;
}
void iris_modifyBase(inout vec2 uv, inout vec4 color, inout vec2 light) {
}
uniform sampler2D irisInt_SpecularMap;
vec4 iris_sampleSpecularMap(vec2 uv) {
	return texture(irisInt_SpecularMap, uv);
}
vec4 iris_sampleSpecularMapLod(vec2 uv, float lod) {
	return textureLod(irisInt_SpecularMap, uv, lod);
}
vec4 iris_sampleSpecularMapGrad(vec2 uv, vec2 dx, vec2 dy) {
	return textureGrad(irisInt_SpecularMap, uv, dx, dy);
}
uniform sampler2D irisInt_NormalMap;
vec4 iris_sampleNormalMap(vec2 uv) {
	return texture(irisInt_NormalMap, uv);
}
vec4 iris_sampleNormalMapLod(vec2 uv, float lod) {
	return textureLod(irisInt_NormalMap, uv, lod);
}
vec4 iris_sampleNormalMapGrad(vec2 uv, vec2 dx, vec2 dy) {
	return textureGrad(irisInt_NormalMap, uv, dx, dy);
}
layout(binding = 0) uniform sampler2D irisInt_BaseTex;
vec4 iris_sampleBaseTex(vec2 uv) {
	return texture(irisInt_BaseTex, uv);
}
vec4 iris_sampleBaseTexLod(vec2 uv, float lod) {
	return textureLod(irisInt_BaseTex, uv, lod);
}
vec4 iris_sampleBaseTexGrad(vec2 uv, vec2 dx, vec2 dy) {
	return textureGrad(irisInt_BaseTex, uv, dx, dy);
}
struct PointData {
	vec4[64] pos;
	int[64] block;
	mat4 projection;
};
struct TimingData {
	float delta;
	float elapsed;
	int frames;
};
struct TemporalData {
	vec3 pos;
	mat4 view;
	mat4 viewInv;
	mat4 projection;
	mat4 projectionInv;
};
struct CameraData {
	vec3 pos;
	float near;
	vec3 fractPos;
	float far;
	ivec3 intPos;
	float renderDistance;
	ivec3 blockPos;
	int fluid;
	vec2 brightness;
	mat4 view;
	mat4 viewInv;
	mat4 projection;
	mat4 projectionInv;
};
struct CelestialData {
	vec3 pos;
	float angle;
	vec3 sunPos;
	float bsl_shadowFade;
	vec3 upPos;
	float makeUp_lightMix;
	vec3 moonPos;
	int phase;
	mat4 view;
	mat4 viewInv;
	mat4[8] projection;
	mat4[8] projectionInv;
};
struct WorldData {
	vec3 skyColor;
	float rain;
	ivec3 internal_chunkDiameter;
	float thunder;
	float fogStart;
	float fogEnd;
	vec4 fogColor;
	int time;
	int day;
};
struct GameData {
	float brightness;
	vec2 screenSize;
	int mainHand;
	int offHand;
	bool guiHidden;
};
layout(binding = 15, std140) uniform DefaultUBO {
	PointData point;
	TimingData time;
	TemporalData temporal;
	CameraData camera;
	CelestialData celestial;
	WorldData world;
	GameData game;
} ap;
#line 1 1
uniform sampler2DArray shadowMap;
uniform sampler2DArrayShadow shadowMapFiltered;
#line 1 3
layout(std430, binding = 0) buffer metadata {
	uint CameraBlockId;
	float AverageLuminance;
	vec3 AmbientColor;
	vec4 LightColor;
};
#line 5 2
layout(std140, binding = 0) uniform settings {
	float Rain;
	float Wetness;
	vec4 LightSunrise;
	vec4 LightMorning;
	vec4 LightNoon;
	vec4 LightAfternoon;
	vec4 LightSunset;
	vec4 LightNightStart;
	vec4 LightMidnight;
	vec4 LightNightEnd;
	vec4 LightRain;
	int ShadowCascadesCount;
	int ShadowSamples;
	int ShadowFilter;
	float ShadowDistort;
	float ShadowSoftness;
	float ShadowBias;
	float ShadowThreshold;
	int ShadingPixelization;
	int ShadowPixelization;
	int Specular;
	float NormalStrength;
	int AutoExposure;
	float ExposureMult;
	float ExposureSpeed;
	int Tonemap;
	bool CompareTonemaps;
	ivec4 TonemapIndices;
};
#line 1 5
vec3 readScene(vec3 compressed) {
	#line 3 5
	return compressed * compressed;
}
#line 8 5
vec3 writeScene(vec3 linear) {
	#line 10 5
	return sqrt(linear);
}
#line 16 5
vec4 readScene(vec4 compressed) {
	return vec4(readScene(compressed.rgb), compressed.a);
}
vec4 writeScene(vec4 linear) {
	return vec4(writeScene(linear.rgb), linear.a);
}
#line 4 4
vec3 linearToSRGB(vec3 linear) {
	return max(1.055f * pow(linear, vec3(0.416666667f)) - 0.055f, 0);
}
vec3 srgbToLinear(vec3 srgb) {
	return srgb * (srgb * (srgb * 0.305306011f + 0.682171111f) + 0.012522878f);
}
#line 11 4
vec4 linearToSRGB(vec4 linear) {
	return vec4(linearToSRGB(linear.rgb), linear.a);
}
vec4 srgbToLinear(vec4 srgb) {
	return vec4(srgbToLinear(srgb.rgb), srgb.a);
}
#line 1 6
vec3 reconstructZ(vec2 normals) {
	return vec3(normals, sqrt(1.0f - clamp(dot(normals, normals), 0.001f, 1.0f)));
}
#line 5 6
vec3 normalsRead(vec2 f) {
	f = f * 2.0f - 1.0f;
	#line 8 6
	vec3 n = vec3(f.x, f.y, 1.0f - abs(f.x) - abs(f.y));
	float t = max(-n.z, 0.0f);
	n.x += n.x >= 0.0f ? -t : t;
	n.y += n.y >= 0.0f ? -t : t;
	return normalize(n);
}
#line 18 6
vec2 octWrap(vec2 v) {
	vec2 w = 1.0f - abs(v.yx);
	if (v.x < 0.0f) w.x = -w.x;
	if (v.y < 0.0f) w.y = -w.y;
	return w;
}
vec2 normalsWrite(vec3 n) {
	n = normalize(n + 1.0E-6f);
	n /= (abs(n.x) + abs(n.y) + abs(n.z));
	n.xy = n.z > 0.0f ? n.xy : octWrap(n.xy);
	return n.xy * 0.5f + 0.5f;
}
#line 1 7
uvec2 writeGBuffer(vec4 gbuffer0, vec4 gbuffer1) {
	return uvec2(packUnorm4x8(gbuffer0), packUnorm4x8(gbuffer1));
}
#line 5 7
void readGBuffer(uvec2 specAndNorm, out vec4 gbuffer0, out vec4 gbuffer1) {
	gbuffer0 = unpackUnorm4x8(specAndNorm.x);
	gbuffer1 = unpackUnorm4x8(specAndNorm.y);
}
#line 3 9
ivec2 shadowMapSize = textureSize(shadowMap, 0).xy;
#line 5 9
float sampleShadowMapNearest(vec3 coord, int cascade) {
	return texture(shadowMap, vec3(coord.xy, cascade)).r;
}
float sampleShadowMap(vec3 coord, int cascade) {
	return texture(shadowMapFiltered, vec4(coord.xy, cascade, coord.z)).r;
}
#line 1 11
void fadeShadows(vec3 playerPos, out float alpha) {
	alpha = 1;
}
#line 5 12
float c = exp2(ShadowDistort) - 1.0f;
float d0 = log2(c + 1.0f);
#line 8 12
vec3 distortShadow(vec3 shadowClipPos) {
	if (ShadowDistort <= 0) return shadowClipPos;
	#line 11 12
	return (sign(shadowClipPos) * log2(c * abs(shadowClipPos) + 1.0f)) / d0;
}
#line 14 12
vec3 distortShadow(vec3 shadowClipPos, out float distortFactor) {
	if (ShadowDistort <= 0) return shadowClipPos;
	#line 17 12
	vec3 absShadowClipPos = abs(shadowClipPos);
	float d = absShadowClipPos.x + absShadowClipPos.y + absShadowClipPos.z;
	distortFactor = (d0 * (c * d + 1.0f)) / c;
	#line 21 12
	return (sign(shadowClipPos) * log2(c * absShadowClipPos + 1.0f)) / d0;
}
#line 1 13
vec2 goldenDiskSample(float index, float count) {
	float theta = index * 2.4f;
	float r = sqrt((index + 0.5f) / count);
	#line 5 13
	return vec2(r * cos(theta), r * sin(theta));
}
#line 1 14
int getCascade(vec3 shadowView) {
	for (int cascade = 0; cascade < ShadowCascadesCount; cascade++) {
		vec3 clip = (ap.celestial.projection[cascade] * vec4(shadowView, 1)).xyz;
		#line 5 14
		if (all(lessThan(clip.xyz, vec3(1))) && all(greaterThan(clip.xyz, vec3(-1)))) {
			return cascade;
		}
	}
	return -1;
}
#line 7 10
float pcfSampleShadow(vec3 coord, float sampleCount, float offset, int cascade) {
	float totalDepth = 0;
	#line 10 10
	for (int i = 0; i < sampleCount; ++i) {
		vec2 sampleOffset = goldenDiskSample(i, sampleCount) * offset;
		#line 13 10
		totalDepth += sampleShadowMap(coord + vec3(sampleOffset.xy, 0), cascade);
	}
	return 1 - (totalDepth / sampleCount);
}
#line 18 10
const float baseSoftness = 0.002f;
float sampleShadowPCF(vec3 shadowScreenPos, int cascade) {
	return pcfSampleShadow(shadowScreenPos, ShadowSamples, baseSoftness * ShadowSoftness, cascade);
}
#line 23 10
float sampleShadowNormal(vec3 shadowScreenPos, int cascade) {
	if (ShadowFilter == 0) {
		return step(sampleShadowMapNearest(shadowScreenPos, cascade), shadowScreenPos.z);
	} else {
		return 1.0f - sampleShadowMap(shadowScreenPos, cascade);
	}
}
#line 32 10
float sampleShadow(vec3 shadowScreenPos, int cascade) {
	if (ShadowFilter <= 1) {
		return sampleShadowNormal(shadowScreenPos, cascade);
	} else if (ShadowFilter == 2) {
		return sampleShadowPCF(shadowScreenPos, cascade);
	}
}
#line 40 10
float calcShadow(vec3 posPlayer, vec3 normalsView) {
	#line 44 10
	float shadowStrength = 1;
	fadeShadows(posPlayer, shadowStrength);
	if (shadowStrength > 0) {
		#line 48 10
		vec3 shadowView = (ap.celestial.view * vec4(posPlayer, 1)).xyz;
		int cascade = getCascade(shadowView);
		if (cascade == -1) return 0;
		#line 52 10
		vec4 shadowClip = ap.celestial.projection[cascade] * vec4(shadowView, 1.0f);
		float distortFac;
		shadowClip.xyz = distortShadow(shadowClip.xyz, distortFac);
		#line 57 10
		float zBias = ShadowBias;
		zBias *= distortFac * (cascade + 1.0f);
		#line 60 10
		vec3 lightDir = normalize(ap.celestial.pos);
		vec2 lightDirWorld = abs(normalize((mat3(ap.camera.viewInv) * lightDir).xz));
		#line 63 10
		float d = abs(dot(normalsView, lightDir));
		zBias *= pow(15, d);
		zBias *= 1 + pow((1.0f - max(lightDirWorld.x, lightDirWorld.y)) * 2.0f, 1.5f) * 18;
		#line 67 10
		shadowClip.z -= zBias;
		#line 69 10
		vec3 shadowNdc = shadowClip.xyz / shadowClip.w;
		vec3 shadowScreen = shadowNdc * 0.5f + 0.5f;
		#line 72 10
		float shadow = sampleShadow(shadowScreen, cascade);
		shadow *= step(ShadowThreshold, shadow);
		#line 75 10
		return shadow * shadowStrength;
	}
	return 0;
}
#line 14 9
float e = 1;
#line 1 15
float roughnessRead(float smoothness) {
	return pow(1.0f - smoothness, 2.0f);
}
float roughnessWrite(float roughness) {
	return 1.0f - sqrt(roughness);
}
#line 9 15
float emissionRead(float emission) {
	return emission < 1 ? emission : 0;
}
#line 13 15
bool isPorosity(float porosity) {
	return porosity < 0.25098039215686274f;
}
#line 18 15
float porosityRead(float porosity, out bool _isPorosity) {
	_isPorosity = isPorosity(porosity);
	#line 21 15
	return _isPorosity ? porosity * 3.984375f : (porosity - 0.25098039215686274f) * 1.3350785340314135f;
}
#line 31 15
float getMetallic(float reflectance) {
	return reflectance > 0.9f ? 1 : 0;
}
#line 36 15
vec3 reflectanceRead(float reflectance, vec3 albedo, int medium) {
	if (reflectance < 0.9f) {
		return vec3(reflectance) * 1.10869565218f;
	} else {
		int value = int(reflectance * 255 + 0.5f);
		#line 43 15
		switch (medium) {
			case 0:
				switch (value) {
					case 230:
						return vec3(0.5312288403511047f, 0.512357234954834f, 0.4958285689353943f);
					case 231:
						return vec3(0.9442299604415894f, 0.7761021256446838f, 0.3734020590782165f);
					case 232:
						return vec3(0.9122980237007141f, 0.9138506054878235f, 0.9196805953979492f);
					case 233:
						return vec3(0.5555968284606934f, 0.5545371174812317f, 0.5547794103622437f);
					case 234:
						return vec3(0.9259521961212158f, 0.7209016680717468f, 0.5041542053222656f);
					case 235:
						return vec3(0.6324838399887085f, 0.6259370446205139f, 0.6414788961410522f);
					case 236:
						return vec3(0.6788492202758789f, 0.6424005627632141f, 0.5884096026420593f);
					case 237:
						return vec3(0.9620000123977661f, 0.9494680762290955f, 0.922115683555603f);
					case 238:
						return vec3(0.6116827726364136f, 0.548520565032959f, 0.5741969347000122f);
					case 239:
						return vec3(0.8771779537200928f, 0.49339383840560913f, 0.7472696304321289f);
					default:
						return albedo * reflectance;
				}
			case 1:
				switch (value) {
					case 230:
						return vec3(0.4367085099220276f, 0.4161258339881897f, 0.4009260833263397f);
					case 231:
						return vec3(0.9304231405258179f, 0.7383231520652771f, 0.2998349070549011f);
					case 232:
						return vec3(0.8861957788467407f, 0.8886891007423401f, 0.8969180583953857f);
					case 233:
						return vec3(0.46233054995536804f, 0.4608496129512787f, 0.46598532795906067f);
					case 234:
						return vec3(0.9073523879051208f, 0.6697537302970886f, 0.42809250950813293f);
					case 235:
						return vec3(0.5540546774864197f, 0.5475188493728638f, 0.5686939358711243f);
					case 236:
						return vec3(0.6035163998603821f, 0.5638218522071838f, 0.5065435171127319f);
					case 237:
						return vec3(0.9518781900405884f, 0.9374012351036072f, 0.9076853394508362f);
					case 238:
						return vec3(0.526247501373291f, 0.4593830704689026f, 0.48603615164756775f);
					case 239:
						return vec3(0.8475667834281921f, 0.4316805899143219f, 0.7012713551521301f);
					default:
						return albedo * reflectance * 0.7501875468867217f;
				}
		}
	}
}
vec3 reflectanceRead(float reflectance, vec3 albedo) {
	return reflectanceRead(reflectance, albedo, 0);
}
float reflectanceWriteFromF0(float f0) {
	return f0 * 0.8980392156862745f;
}
#line 15 16
float distributionGGX(float NdotH, float alpha) {
	float alpha2 = alpha * alpha;
	return alpha2 / (3.14159265359f * pow(NdotH * NdotH * (alpha2 - 1.0f) + 1.0f, 2));
}
#line 21 16
float geometric(float NdotM, float alpha) {
	float k = alpha * 0.5f;
	return NdotM / (NdotM * (1 - k) + k);
}
#line 27 16
vec3 fresnelSchlick(float NdotV, vec3 f0) {
	return f0 + (1.0f - f0) * pow(1.0f - NdotV, 5.0f);
}
vec3 calcSpecular(vec3 inDir, vec3 outDir, vec3 normal, float roughness, vec3 f0, out vec3 kS) {
	#line 32 16
	float alpha = roughness * roughness;
	vec3 halfway = normalize(inDir + outDir);
	#line 35 16
	float NdotL = max(dot(normal, inDir), 0);
	float NdotV = max(dot(normal, outDir), 1.0E-5f);
	float NdotH = max(dot(normal, halfway), 0);
	#line 39 16
	vec3 fresnel = fresnelSchlick(NdotV, f0);
	vec3 radiance = (distributionGGX(NdotH, alpha) * geometric(NdotV, alpha) * geometric(NdotL, alpha) * fresnel) / (4 * NdotL * NdotV);
	#line 42 16
	kS += fresnel;
	return max(radiance, 0);
}
#line 8 18
float diffuseBurley(float NdotL, float NdotV, float LdotH, float roughness) {
	#line 10 18
	float f90MinusOne = 0.5f + 2.0f * roughness * LdotH * LdotH - 1.0f;
	return 0.31830988618f * (1.0f + f90MinusOne * pow(1 - NdotL, 5)) * (1.0f + f90MinusOne * pow(1 - NdotV, 5));
}
#line 14 18
float calcDiffuseFactor(vec3 inDir, vec3 outDir, vec3 normal, float roughness) {
	vec3 halfway = normalize(inDir + outDir);
	float NdotL = max(dot(normal, inDir), 0.0f);
	float NdotV = max(dot(normal, outDir), 0.0f);
	float LdotH = max(dot(inDir, halfway), 0.0f);
	#line 21 18
	float diffuseFac = 3.14159265359f * NdotL * diffuseBurley(NdotL, NdotV, LdotH, roughness);
	#line 23 18
	return diffuseFac;
}
#line 10 19
float fresnelSchlick(float cosTheta, float f0) {
	return f0 + (1.0f - f0) * pow(1.0f - cosTheta, 5.0f);
}
#line 14 19
float distributionGTR1(float alpha2, float NdotH) {
	float alpha2MinusOne = alpha2 - 1;
	#line 17 19
	return alpha2MinusOne / (3.14159265359f * log2(alpha2) * (1 + alpha2MinusOne * NdotH * NdotH));
}
#line 20 19
float geometricSmithGGX(float alpha2, float NdotM) {
	return 1.0f / (NdotM + sqrt(alpha2 + NdotM - alpha2 * NdotM * NdotM));
}
#line 25 19
vec3 clearcoat(vec3 coatColor, vec3 inDir, vec3 outDir, vec3 normal, float roughness, float f0) {
	float alpha2 = roughness * roughness * roughness * roughness;
	#line 28 19
	vec3 halfway = normalize(inDir + outDir);
	float NdotL = max(dot(normal, inDir), 0);
	float NdotV = max(dot(normal, outDir), 0);
	float NdotH = max(dot(normal, halfway), 0);
	float cosTheta = max(dot(inDir, halfway), 0);
	#line 34 19
	return coatColor * (distributionGTR1(alpha2, NdotH) - 0.04f) * fresnelSchlick(cosTheta, f0) * geometricSmithGGX(alpha2, NdotL) * geometricSmithGGX(alpha2, NdotV) * 0.25f;
}
#line 1 20
vec4 permute(vec4 x) {
	#line 1 20
	return mod(((x * 34.0f) + 1.0f) * x, 289.0f);
}
#line 2 20
vec4 taylorInvSqrt(vec4 r) {
	#line 2 20
	return 1.79284291400159f - 0.85373472095314f * r;
}
float noiseSimplex(vec3 v) {
	vec2 C = vec2(0.16666666666666666f, 0.3333333333333333f);
	vec4 D = vec4(0.0f, 0.5f, 1.0f, 2.0f);
	#line 9 20
	vec3 i = floor(v + dot(v, C.yyy));
	vec3 x0 = v - i + dot(i, C.xxx);
	#line 13 20
	vec3 g = step(x0.yzx, x0.xyz);
	vec3 l = 1.0f - g;
	vec3 i1 = min(g.xyz, l.zxy);
	vec3 i2 = max(g.xyz, l.zxy);
	#line 19 20
	vec3 x1 = x0 - i1 + 1.0f * C.xxx;
	vec3 x2 = x0 - i2 + 2.0f * C.xxx;
	vec3 x3 = x0 - 1.0f + 3.0f * C.xxx;
	#line 24 20
	i = mod(i, 289.0f);
	vec4 p = permute(permute(permute(i.z + vec4(0.0f, i1.z, i2.z, 1.0f)) + i.y + vec4(0.0f, i1.y, i2.y, 1.0f)) + i.x + vec4(0.0f, i1.x, i2.x, 1.0f));
	#line 32 20
	float n_ = 1.0f / 7.0f;
	vec3 ns = n_ * D.wyz - D.xzx;
	#line 35 20
	vec4 j = p - 49.0f * floor(p * ns.z * ns.z);
	#line 37 20
	vec4 x_ = floor(j * ns.z);
	vec4 y_ = floor(j - 7.0f * x_);
	#line 40 20
	vec4 x = x_ * ns.x + ns.yyyy;
	vec4 y = y_ * ns.x + ns.yyyy;
	vec4 h = 1.0f - abs(x) - abs(y);
	#line 44 20
	vec4 b0 = vec4(x.xy, y.xy);
	vec4 b1 = vec4(x.zw, y.zw);
	#line 47 20
	vec4 s0 = floor(b0) * 2.0f + 1.0f;
	vec4 s1 = floor(b1) * 2.0f + 1.0f;
	vec4 sh = -step(h, vec4(0.0f));
	#line 51 20
	vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
	vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
	#line 54 20
	vec3 p0 = vec3(a0.xy, h.x);
	vec3 p1 = vec3(a0.zw, h.y);
	vec3 p2 = vec3(a1.xy, h.z);
	vec3 p3 = vec3(a1.zw, h.w);
	#line 60 20
	vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
	p0 *= norm.x;
	p1 *= norm.y;
	p2 *= norm.z;
	p3 *= norm.w;
	#line 67 20
	vec4 m = max(0.6f - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0f);
	m = m * m;
	return 42.0f * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));
}
#line 1 21
vec4 mod289(vec4 x) {
	#line 1 21
	return x - floor(x * (1.0f / 289.0f)) * 289.0f;
}
#line 2 21
vec4 perm(vec4 x) {
	#line 2 21
	return mod289(((x * 34.0f) + 1.0f) * x);
}
float noise(vec3 p) {
	vec3 a = floor(p);
	vec3 d = p - a;
	d = d * d * (3.0f - 2.0f * d);
	#line 9 21
	vec4 b = a.xxyy + vec4(0.0f, 1.0f, 0.0f, 1.0f);
	vec4 k1 = perm(b.xyxy);
	vec4 k2 = perm(k1.xyxy + b.zzww);
	#line 13 21
	vec4 c = k2 + a.zzzz;
	vec4 k3 = perm(c);
	vec4 k4 = perm(c + 1.0f);
	#line 17 21
	vec4 o1 = fract(k3 * (1.0f / 41.0f));
	vec4 o2 = fract(k4 * (1.0f / 41.0f));
	#line 20 21
	vec4 o3 = o2 * d.z + o1 * (1.0f - d.z);
	vec2 o4 = o3.yw * d.x + o3.xz * (1.0f - d.x);
	#line 23 21
	return o4.y * d.y + o4.x * (1.0f - d.y);
}
#line 1 22
vec3 depthToViewPos(vec2 fragCoord, float depth, mat4 projInverse) {
	vec4 ndc = vec4(fragCoord, depth, 1) * 2.0f - 1.0f;
	vec4 viewPos = projInverse * ndc;
	return viewPos.xyz / viewPos.w;
}
#line 7 22
vec3 depthToViewPos(vec2 fragCoord, float depth) {
	return depthToViewPos(fragCoord, depth, ap.camera.projectionInv);
}
#line 11 22
vec3 calcViewDir(vec2 fragCoord) {
	return normalize(depthToViewPos(fragCoord, -1, ap.camera.projectionInv));
}
#line 1 24
uniform float eyeAltitude;
#line 8 25
vec3 sunDir = mat3(ap.camera.viewInv) * normalize(ap.celestial.sunPos);
#line 14 25
vec3 moonDir = mat3(ap.camera.viewInv) * normalize(ap.celestial.moonPos);
#line 21 25
const float g = -0.93f;
const float g2 = g * g;
#line 24 25
const vec3 betaR = vec3(0.0195f, 0.11f, 0.294f);
const vec3 betaM = vec3(0.042f, 0.04f, 0.04f);
#line 27 25
vec3 ACES(vec3 v) {
	v *= 0.6f;
	return (v * (2.51f * v + 0.03f)) / (v * (2.43f * v + 0.59f) + 0.14f);
}
#line 32 25
float brightness(vec3 color) {
	return 0.299f * color.r + 0.587f * color.g + 0.114f * color.b;
}
#line 37 25
vec3 rotateAroundZ(vec3 v, float angle) {
	float s = sin(angle);
	float c = cos(angle);
	return vec3(c * v.x - s * v.y, s * v.x + c * v.y, v.z);
}
#line 47 25
vec3 rotateAroundX(vec3 v, float angle) {
	float s = sin(angle);
	float c = cos(angle);
	return vec3(v.x, c * v.y - s * v.z, s * v.y + c * v.z);
}
#line 58 25
vec3 skyCustom(vec3 viewDir, vec3 lightDir, vec2 intensity, vec2 attenuation) {
	#line 61 25
	float t = viewDir.y < 0 ? -viewDir.y / max(eyeAltitude, 10) : viewDir.y;
	#line 63 25
	float sR = 0.7f * attenuation.x / t;
	float sM = 0.8f * attenuation.y / t;
	#line 66 25
	float cosine = max(dot(viewDir, lightDir), 0);
	vec3 extinction = exp(-(betaR * sR + betaM * sM));
	#line 69 25
	const float g2 = g * g;
	float fcos2 = cosine * cosine;
	float miePhase = 1.0f * intensity.y * pow(1.0f + g2 + 2.0f * g * cosine, -1.5f) * (1.0f - g2) / (2.0f + g2);
	vec3 inScatter = (1 + fcos2) * vec3(1.0f * intensity.x + betaM / betaR * miePhase * (1 - extinction));
	#line 74 25
	vec3 sunHaze = ACES(inScatter * (1 - extinction));
	#line 78 25
	return vec3(clamp(sunHaze, 0, 1));
}
#line 81 25
vec3 _skyCustomNoStars(inout vec3 viewDir, vec2 intensity, vec2 attenuation) {
	float sunness = max(sunDir.y, 0);
	float moonness = max(moonDir.y, 0);
	#line 85 25
	float altitudeBias = eyeAltitude * 1.0E-4f;
	viewDir.y += altitudeBias;
	viewDir = normalize(viewDir);
	if (altitudeBias > 1) {
		return vec3(0);
	}
	#line 92 25
	float _moonIntensity = mix(0, 0.01f, moonness);
	#line 96 25
	vec2 moonIntensity = vec2(_moonIntensity);
	#line 99 25
	vec2 sunIntensity = vec2(mix(0.05f, 1, sunness));
	#line 105 25
	return skyCustom(viewDir, sunDir, sunIntensity * intensity, vec2(1) * attenuation) * min(sunness + 0.5f, 1) + skyCustom(viewDir, moonDir, moonIntensity * intensity, vec2(mix(4, 10, moonness)) * attenuation) * min(moonness + 0.5f, 1);
}
#line 110 25
vec3 skyCustomNoStars(in vec3 viewDir, vec2 intensity, vec2 attenuation) {
	return _skyCustomNoStars(viewDir, intensity, attenuation);
}
#line 114 25
vec3 skyCustomNoStars(in vec3 viewDir) {
	return skyCustomNoStars(viewDir, vec2(1), vec2(1));
}
#line 118 25
vec3 skyCustom(vec3 viewDir, vec2 intensity, vec2 attenuation) {
	vec3 sky = _skyCustomNoStars(viewDir, intensity, attenuation);
	#line 122 25
	return sky;
}
#line 131 25
vec3 skyCustom(vec3 viewDir) {
	return skyCustom(viewDir, vec2(1), vec2(1));
}
#line 6 24
vec3 calcSky(vec3 dir, vec2 intensity, vec2 attenuation) {
	return skyCustomNoStars(mat3(ap.camera.viewInv) * dir, intensity, attenuation);
}
#line 10 24
vec3 calcSky(vec3 dir) {
	return skyCustomNoStars(mat3(ap.camera.viewInv) * dir);
}
#line 14 24
vec3 calcSkyWithStars(vec3 dir) {
	return skyCustom(mat3(ap.camera.viewInv) * dir);
}
#line 3 23
const float defaultSampleMult = 2;
#line 5 23
vec3 calcSkyReflection(float sampleMult, vec3 viewDir, vec3 normals, float roughness, float skylight) {
	#line 7 23
	if (sampleMult < 0) return vec3(0);
	#line 9 23
	float sampleCount = floor(1 + (roughness * sampleMult));
	vec3 ambientSpecular;
	if (skylight * skylight > 0.0625f) {
		for (int i = 0; i < int(sampleCount); i++) {
			vec3 currentNormals = normalize(normals + roughness * vec3(goldenDiskSample(i, sampleCount), 0).xzy);
			ambientSpecular += calcSky(mix(reflect(viewDir, currentNormals), currentNormals, min(roughness + 0.2f, 0.1f))) * skylight * skylight * (1 - roughness);
		}
		ambientSpecular /= sampleCount;
	}
	#line 19 23
	return ambientSpecular;
}
#line 22 23
vec3 calcSkyReflection(vec3 normals, vec3 viewDir, float roughness, float skylight) {
	return calcSkyReflection(defaultSampleMult, viewDir, normals, roughness, skylight);
}
#line 2 26
struct Material {
	float roughness;
	vec3 normals;
	float porosity;
	float sss;
	float emission;
	float ao;
	float height;
	vec3 f0;
	float metallic;
};
#line 15 26
Material Mat(vec3 albedo, vec4 gbuffer0, vec4 gbuffer1) {
	float roughness = roughnessRead(gbuffer0.r);
	float reflectance = gbuffer0.g;
	bool isPorosity = false;
	float porosity = porosityRead(gbuffer0.b, isPorosity);
	float emission = emissionRead(gbuffer0.a);
	vec3 normals = mat3(ap.camera.view) * normalsRead(gbuffer1.rg);
	#line 23 26
	return Material(roughness, normals, isPorosity ? porosity : -1, !isPorosity ? porosity : -1, emission, 0, 0.0f, reflectanceRead(reflectance, albedo), getMetallic(reflectance));
}
#line 26 26
Material Mat(vec3 albedo, uvec2 gbuffer) {
	vec4 gbuffer0;
	#line 27 26
	vec4 gbuffer1;
	#line 27 26
	readGBuffer(gbuffer, gbuffer0, gbuffer1);
	return Mat(albedo, gbuffer0, gbuffer1);
}
#line 2 27
vec3 lightDir = normalize(ap.celestial.pos);
vec3 upDir = normalize(ap.celestial.upPos);
#line 6 27
const vec3 puddleScale = vec3(1, 1, 1);
#line 17 27
const vec3 PUDDLE_COLOR = vec3(0.8f, 0.8f, 0.85f);
#line 21 27
bool shade(inout vec4 color, inout Material material, vec2 lightLevel, vec3 posView, out float shadow) {
	bool editGBuffers = false;
	float skylight = lightLevel.y;
	#line 25 27
	vec3 posWorld = (mat3(ap.camera.viewInv) * posView) + ap.camera.pos + ap.camera.viewInv[3].xyz;
	vec3 _posWorld = posWorld;
	if (ShadingPixelization != 0) {
		posWorld = ((ShadingPixelization == 0) ? (posWorld) : floor((posWorld) * ShadingPixelization + 0.003f) / ShadingPixelization);
		#line 30 27
		posView = (ap.camera.view * vec4(posWorld - ap.camera.pos, 1)).xyz;
	}
	vec3 viewDir = normalize(posView);
	#line 34 27
	vec3 albedo = color.rgb;
	vec3 normals = material.normals;
	float roughness = material.roughness;
	float porosity = material.porosity;
	vec3 f0 = material.f0;
	float emission = material.emission;
	float metallic = material.metallic;
	vec3 outDir = -viewDir;
	#line 43 27
	vec3 shadowPosWorld = _posWorld;
	if (ShadowPixelization != 0) shadowPosWorld += (mat3(ap.camera.viewInv) * normals) * (0.75f / ShadowPixelization);
	#line 46 27
	vec3 kS = vec3(0.0f);
	vec3 specular = vec3(0);
	if (Specular == 1) {
		specular = calcSpecular(lightDir, outDir, normals, roughness, f0, kS);
	}
	vec3 kD = 1 - kS;
	float diffuseFactor = calcDiffuseFactor(lightDir, outDir, normals, roughness);
	if (diffuseFactor > 0) {
		shadow = calcShadow(((ShadowPixelization == 0) ? (shadowPosWorld) : floor((shadowPosWorld) * ShadowPixelization + 0.003f) / ShadowPixelization) - ap.camera.pos, normals);
	}
	#line 57 27
	float visibility = min(diffuseFactor, 1 - shadow) * LightColor.a;
	vec3 diffuse = albedo * (1 - metallic) * kD;
	#line 60 27
	color.rgb = (diffuse + specular) * min(diffuseFactor, 1 - shadow) * LightColor.a * LightColor.rgb + skylight * albedo * AmbientColor.rgb + albedo * emission;
	#line 68 27
	if (Wetness > 0.001f) {
		float upness = dot(normals, upDir);
		float skyExposure = clamp(smoothstep(0.2f, 0.7f, skylight), 0, 1);
		#line 72 27
		vec3 noiseCoord = posWorld * puddleScale;
		float distortion = noise(noiseCoord * 1);
		vec3 distort = max(vec3(-distortion, 0, distortion), 0);
		float puddle = (noiseSimplex(noiseCoord * (1 - 1) + distort * 1) * 0.5f + 0.5f);
		puddle = puddle - mix(1 - 1, 0.1f, Rain) - (1 - skyExposure);
		puddle = clamp(puddle * (0.5f + upness * 0.5f) * Rain * 1, 0, 1);
		#line 79 27
		vec3 puddleNormal = upness > 0.2f ? mix(normals, upDir, clamp(puddle * 1 * mix(0.5f, 1, Wetness), 1 * 0.45f, 1)) : normals;
		color.rgb *= 0.8f + ((1 - puddle) * mix(0.6f, 0.1f, porosity)) * PUDDLE_COLOR;
		color.rgb += clearcoat(PUDDLE_COLOR, lightDir, outDir, puddleNormal, 0.7f, 0.3f) * puddle * visibility;
		#line 84 27
		material.roughness = mix(roughness, 0.7f, puddle);
		material.normals = mix(normals, puddleNormal, puddle);
		if (f0.x == f0.y && f0.y == f0.z) {
			material.f0 = vec3(mix(f0.x, 0.3f, puddle));
		}
		editGBuffers = true;
	}
	#line 93 27
	return editGBuffers;
}
#line 96 27
void writeMaterial(Material material, inout vec4 GBuffer0, inout vec4 GBuffer1) {
	GBuffer0.r = roughnessWrite(material.roughness);
	GBuffer1.rg = normalsWrite(mat3(ap.camera.viewInv) * (material.normals));
	GBuffer0.g = reflectanceWriteFromF0(material.f0.x);
}
#line 10 0
uniform sampler2D solidDepthTex;
#line 12 0
in vec2 texCoord;
in vec3 vertColor;
in mat3 tbn;
in vec3 posView;
flat in uint blockId;
#line 22 0
layout(location = 0) out vec4 Color;
layout(location = 1) out uvec2 GBuffer;
#line 25 0
void iris_emitFragment() {
	vec4 texColor = iris_sampleBaseTex(texCoord);
	#line 31 0
	Color = vec4(vertColor.rgb * srgbToLinear(texColor.rgb), texColor.a);
	#line 33 0
	float lod = clamp(textureQueryLod(irisInt_SpecularMap, texCoord).y, 0, 1);
	vec4 gbuffer0 = mix(iris_sampleSpecularMapLod(texCoord, floor(lod)), iris_sampleSpecularMapLod(texCoord, ceil(lod)), fract(lod));
	vec4 gbuffer1 = mix(iris_sampleNormalMapLod(texCoord, floor(lod)), iris_sampleNormalMapLod(texCoord, ceil(lod)), fract(lod));
	#line 37 0
	vec2 normal = (gbuffer1.rg * 2.0f) - 1.0f;
	gbuffer1.rg = normalsWrite(tbn * reconstructZ(normal * NormalStrength));
	#line 58 0
	GBuffer = writeGBuffer(gbuffer0, gbuffer1);
	Color = writeScene(Color);
}
void main() {
	iris_emitFragment();
}
